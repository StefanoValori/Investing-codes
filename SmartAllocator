# =========================================================
# MONTHLY SMART ALLOCATOR
# =========================================================

import yfinance as yf
import pandas as pd
import numpy as np
import math, warnings, logging
import matplotlib.pyplot as plt

warnings.filterwarnings("ignore")
logging.getLogger("yfinance").setLevel(logging.CRITICAL)

plt.rcParams["figure.figsize"] = (8, 3.5)

# =============== USER SETTINGS ==================

CAPITAL = 1000          # Capitale da allocare

TOP_WINNERS = 3
HONORABLE_MENTIONS = 15

PERIOD_LONG = "10y"
MIN_YEARS = 5

# Stable dividend constraints
STABLE_MIN_DY = 0.02
STABLE_MAX_DY = 0.06
STABLE_MAX_PAYOUT = 0.80
STABLE_MAX_DD = -0.55
STABLE_MAX_VOL = 0.30
STABLE_MIN_R2 = 0.65
STABLE_MIN_SLOPE = 0.02

# Growth constraints
GROWTH_MIN_CAGR5 = 0.10
GROWTH_MAX_DD = -0.65
GROWTH_MAX_VOL = 0.45
GROWTH_MIN_R2 = 0.60
GROWTH_MIN_SLOPE = 0.08

# Entry filters comuni (price action)
LOOK_Z = 200
LOOK_DD = 252
DD12_MIN = -0.45
DD12_MAX = 0.10

# ETF / Exposures
ETF_TOP = 3

# =============== UNIVERSE (ESPANSO) =======================

STABLE_UNIVERSE = [
    # US staples & consumer
    "KO","PEP","PG","CL","KMB","MDLZ","WMT","COST","MO","PM",
    "KHC","UL","CPB","HSY",
    # US healthcare
    "JNJ","ABBV","MRK","AMGN","BMY","PFE","LLY",
    # US utilities & infra
    "NEE","SO","DUK","AEP","XEL","SRE","D","ED","WEC",
    # US telecom
    "T","VZ",
    # US financials / insurance / AM
    "JPM","BAC","WFC","C","GS","MS","USB","PNC","BK","AXP",
    "BLK","TROW","SCHW","SPGI",
    "PRU","MET","AFL","TRV","CB","ALL",
    # US other quality income
    "MCD","YUM","TXN","IBM","LMT","RTX","WM","HD","LOW","O","PLD","CSCO",
    # Canada
    "ENB.TO","TRP.TO","PPL.TO","BCE.TO","T.TO","FTS.TO",
    "RY.TO","TD.TO","BNS.TO","CM.TO",
    # UK
    "ULVR.L","DGE.L","BATS.L","GSK.L","AZN.L","NG.L","SSE.L","HSBA.L","BP.L","SHEL.L",
    # Europe core
    "NESN.SW","ROG.SW","NOVN.SW","ZURN.SW",
    "SAN.PA","OR.PA","SU.PA","TTE.PA","DG.PA",
    "ALV.DE","MUV2.DE","SIE.DE","BAS.DE","BAYN.DE",
    "ENEL.MI","ENI.MI","ISP.MI","UCG.MI",
    # Nordics
    "NESTE.HE","TELIA.ST","SWMA.ST",
    # Aus / altri
    "WES.AX","WOW.AX","CBA.AX","WBC.AX","NAB.AX","ANZ.AX",
    "RIO.L","BHP.AX"
]

GROWTH_UNIVERSE = [
    # US mega tech & AI
    "MSFT","AAPL","AMZN","GOOGL","META",
    "NVDA","AVGO","ADBE","CRM","INTU","NOW",
    # SaaS / software quality
    "MSCI","SNOW","PLTR","ADP","FICO","CDNS","SNPS",
    # Payments & platforms
    "MA","V","PYPL",
    # Semi & hardware
    "TXN","LRCX","ASML.AS","TSM","AMD","MU","ADI","NXPI",
    # US quality growth
    "COST","MCD","LIN","SHW","ROP","SPGI","ELV","UNH","ETN","PH","GE","WM",
    "NFLX","CHTR",
    # Luxury & EU growth
    "MC.PA","OR.PA","LVMH.PA","SU.PA","KER.PA",
    "SAP.DE","SIE.DE","AIR.PA",
    # Asia / altre
    "CSL.AX","SONY","TCS.NS","INFY.NS","RELIANCE.NS",
    "SE","TME"
]

ETF_UNIVERSE = [
    # Global equity core
    "SWDA.L","IWDA.AS","VWCE.DE","ACWI","VT",
    # US broad / quality / dividend
    "SPY","VOO","IVV","VTI","VIG","SCHD","VYM",
    # International / high dividend
    "VHYL.L","HDV","DVY",
    # Satelliti: Bitcoin & Gold (gestiti con logica dedicata)
    "BTC-USD","GLD"
]

GBX_EXCEPT = {"SWDA.L","VHYL.L"}

# =============== HELPERS ========================

def safe(x, default=np.nan):
    try:
        if x is None:
            return default
        return float(x)
    except:
        return default

def is_gbx(sym: str) -> bool:
    return sym.endswith(".L") and sym not in GBX_EXCEPT

def clean_series(s: pd.Series, base_max_jump: float = 0.12) -> pd.Series:
    """
    Rimuove spike anomali:
    - outlier globali: |ret - med| > 5 * std
    - outlier locali: |ret| > base_max_jump e > 4 * rolling_std_20
    """
    if s.empty:
        return s

    r = s.pct_change()
    r_valid = r.dropna()
    if r_valid.empty:
        return s

    med = r_valid.median()
    std = r_valid.std()
    roll_std = r.rolling(20, min_periods=5).std()

    bad = pd.Series(False, index=r.index)

    if std and std > 0:
        bad |= (r - med).abs() > 5 * std

    local_cond = (r.abs() > base_max_jump)
    local_cond &= (r.abs() > 4 * roll_std.fillna(std if std > 0 else 0.5))
    bad |= local_cond

    if bad.any():
        s = s.copy()
        s[bad] = np.nan
        s = s.interpolate(limit_direction="both")

    return s

def download_price(sym, period=PERIOD_LONG):
    try:
        t = yf.Ticker(sym)
        h = t.history(period=period, auto_adjust=True)
        if h is None or h.empty:
            return pd.Series(dtype=float)
        s = h["Close"].dropna()
        if is_gbx(sym):
            s = s * 0.01
        s = clean_series(s)
        return s
    except:
        return pd.Series(dtype=float)

def get_dividend_stats(sym, price):
    t = yf.Ticker(sym)
    dy = np.nan
    cagr5 = 0.0
    payout = safe((t.info or {}).get("payoutRatio", np.nan))

    # TTM yield da dividendi effettivi
    try:
        div = t.dividends
        if div is not None and len(div) > 0 and price and price > 0:
            cutoff = div.index.max() - pd.Timedelta(days=365)
            ttm = float(div[div.index >= cutoff].sum())
            if ttm > 0:
                dy = ttm / price
    except:
        pass

    # fallback info
    if (math.isnan(dy) or dy == 0.0):
        try:
            info_dy = safe((t.info or {}).get("dividendYield", np.nan))
            if info_dy > 0:
                dy = info_dy
        except:
            pass

    # Dividend CAGR 5y
    try:
        div = t.dividends
        if div is not None and len(div) > 0:
            by = div.groupby(div.index.year).sum()
            by = by[by > 0]
            if len(by) >= 5:
                y0 = by.index.min()
                yN = by.index.max()
                if yN - y0 >= 4 and by.loc[y0] > 0:
                    n = yN - y0
                    cagr5 = (by.loc[yN] / by.loc[y0])**(1/n) - 1
    except:
        pass

    return dy, cagr5, payout

def linear_and_entry_metrics(s: pd.Series):
    s = s.dropna()
    if len(s) < 252 * MIN_YEARS:
        return (np.nan,)*7

    # Trend log-prezzo
    y = np.log(s.values)
    x = np.arange(len(y))
    x_mean, y_mean = x.mean(), y.mean()
    cov_xy = ((x-x_mean)*(y-y_mean)).sum()
    var_x = ((x-x_mean)**2).sum()
    if var_x == 0:
        return (np.nan,)*7
    beta = cov_xy / var_x
    alpha = y_mean - beta*x_mean
    y_hat = alpha + beta*x
    ss_tot = ((y-y_mean)**2).sum()
    ss_res = ((y-y_hat)**2).sum()
    r2 = 1 - ss_res/ss_tot if ss_tot > 0 else np.nan
    slope_annual = beta * 252

    # Max drawdown & vol
    roll_max = s.cummax()
    dd = (s / roll_max - 1.0).min()
    ret = s.pct_change().dropna()
    vol = ret.std() * np.sqrt(252) if len(ret) > 20 else np.nan

    # Z-score 200d
    if len(s) >= LOOK_Z:
        ma = s.rolling(LOOK_Z).mean()
        st = s.rolling(LOOK_Z).std()
        if not math.isnan(ma.iloc[-1]) and not math.isnan(st.iloc[-1]) and st.iloc[-1] > 0:
            z = (s.iloc[-1] - ma.iloc[-1]) / st.iloc[-1]
        else:
            z = np.nan
    else:
        z = np.nan

    # DD 12 mesi
    if len(s) >= LOOK_DD:
        dd12 = s.iloc[-1] / s.iloc[-LOOK_DD:].max() - 1.0
    else:
        dd12 = np.nan

    # CAGR 5y
    cagr5 = np.nan
    if len(s) >= 252*5:
        p0 = s.iloc[-252*5]
        if p0 > 0:
            cagr5 = (s.iloc[-1] / p0)**(1/5) - 1

    return slope_annual, r2, dd, vol, z, dd12, cagr5

def rank01(series, asc=True):
    s = pd.Series(series, dtype=float).replace([np.inf,-np.inf], np.nan)
    r = s.rank(pct=True, ascending=asc)
    return r.fillna(0.0).clip(0,1)

# =============== STEP 1: MARKET SENTIMENT =================

def pick_world_etf():
    cands = ["SWDA.L","IWDA.AS","VWCE.DE","ACWI","VT","URTH"]
    for c in cands:
        s = download_price(c, "3y")
        if not s.empty:
            return c
    return None

def market_sentiment():
    spy = download_price("SPY", "3y")
    world_sym = pick_world_etf()
    world = download_price(world_sym, "3y") if world_sym else pd.Series(dtype=float)

    vix_hist = yf.download("^VIX", period="3y", auto_adjust=True, progress=False)
    vix = vix_hist["Close"].dropna() if not vix_hist.empty else pd.Series(dtype=float)

    if spy.empty or world.empty or vix.empty:
        return {
            "regime": "Neutral (fallback)",
            "world_etf": world_sym or "SWDA.L",
            "weights": {"STABLE_DIV":0.40,"ETF_CORE":0.15,"GROWTH":0.45},
            "metrics": {}
        }

    def zscore_200(s):
        if len(s) < 200:
            return np.nan
        ma = s.rolling(200).mean()
        st = s.rolling(200).std()
        if st.iloc[-1] == 0 or math.isnan(ma.iloc[-1]) or math.isnan(st.iloc[-1]):
            return np.nan
        return (s.iloc[-1] - ma.iloc[-1]) / st.iloc[-1]

    z_spy = zscore_200(spy)
    z_world = zscore_200(world)
    r6_spy = spy.iloc[-1] / spy.iloc[-126] - 1 if len(spy) >= 126 else np.nan
    r6_world = world.iloc[-1] / world.iloc[-126] - 1 if len(world) >= 126 else np.nan
    vix_now = float(vix.iloc[-1])
    vix_30d = (vix_now / 100.0) * math.sqrt(30.0 / 365.0)
    vix_30d_pct = vix_30d * 100.0

    # Regime di mercato (contrarian soft)
    if (z_spy < -0.7 or z_world < -0.7 or r6_spy < -0.10 or r6_world < -0.10) or vix_now > 28:
        regime = "Risk-Off / Panic"
        weights = {"STABLE_DIV":0.45,"ETF_CORE":0.30,"GROWTH":0.25}
    elif (z_spy < 0 or z_world < 0 or r6_spy < 0 or r6_world < 0 or 20 < vix_now <= 28):
        regime = "Cautious / Defensive"
        weights = {"STABLE_DIV":0.40,"ETF_CORE":0.25,"GROWTH":0.35}
    elif (z_spy > 1.0 and z_world > 1.0 and vix_now < 15 and r6_spy > 0.10 and r6_world > 0.10):
        regime = "Euphoric / Expensive"
        weights = {"STABLE_DIV":0.45,"ETF_CORE":0.30,"GROWTH":0.25}
    else:
        regime = "Neutral / Healthy"
        weights = {"STABLE_DIV":0.40,"ETF_CORE":0.15,"GROWTH":0.45}

    # SPY vs Global ETF rebased
    plt.style.use("dark_background")
    base_spy = spy / spy.iloc[0] * 100
    base_world = world / world.iloc[0] * 100

    plt.figure(figsize=(9,3))
    plt.plot(base_spy.index, base_spy.values, lw=1.5, label="SPY", color="#9bd3ff")
    plt.plot(base_world.index, base_world.values, lw=1.5, label=world_sym, color="#8cff9b")
    plt.title("SPY vs Global ETF — Rebased 100 (3y)", color="white")
    plt.legend(facecolor="black")
    plt.grid(alpha=0.2)
    plt.tight_layout()
    plt.show()

    # VIX
    plt.figure(figsize=(9,3))
    plt.plot(vix.index, vix.values, lw=1.2, color="orange")
    plt.axhline(20, ls="--", alpha=0.3, color="gray")
    plt.axhline(30, ls="--", alpha=0.3, color="gray")
    plt.title("VIX (3y)", color="white")
    plt.grid(alpha=0.2)
    plt.tight_layout()
    plt.show()

    metrics = {
        "z_spy": z_spy,
        "z_world": z_world,
        "r6_spy": r6_spy,
        "r6_world": r6_world,
        "vix": vix_now,
        "vix_30d_pct": vix_30d_pct
    }

    return {
        "regime": regime,
        "world_etf": world_sym,
        "weights": weights,
        "metrics": metrics
    }

sent = market_sentiment()

print("\n=== MARKET SENTIMENT ===")
print(f"Regime: {sent['regime']}")
print(f"Global ETF usato: {sent['world_etf']}")

m = sent["metrics"]
if m:
    print(f"z_spy (deviazione vs media a 200 gg): {m['z_spy']:.4f}")
    print(f"z_world (deviazione vs media a 200 gg): {m['z_world']:.4f}")
    print(f"r6_spy (rendimento ultimi 6 mesi): {m['r6_spy']*100:.2f}%")
    print(f"r6_world (rendimento ultimi 6 mesi): {m['r6_world']*100:.2f}%")
    print(f"VIX: {m['vix']:.2f}  -> volatilità attesa 30 gg ≈ ±{m['vix_30d_pct']:.2f}%")

print("\nSuggested bucket weights:")
for k, v in sent["weights"].items():
    print(f"- {k}: {v*100:.1f}%")

# Pie chart allocazione bucket
plt.style.use("dark_background")
fig, ax = plt.subplots(figsize=(4,4))
fig.patch.set_facecolor("black")
ax.set_facecolor("black")

labels = ["Stable Div", "ETF Core/Exposures", "High Growth"]
sizes = [
    sent["weights"]["STABLE_DIV"],
    sent["weights"]["ETF_CORE"],
    sent["weights"]["GROWTH"]
]
colors = ["#00c8ff", "#ffd700", "#b388ff"]

wedges, texts, autotexts = ax.pie(
    sizes,
    labels=labels,
    autopct="%1.1f%%",
    startangle=90,
    colors=colors
)
for txt in texts:
    txt.set_color("white")
for at in autotexts:
    at.set_color("black")
    at.set_fontsize(9)

ax.set_title("Bucket Allocation", color="white")
ax.axis("equal")
plt.tight_layout()
plt.show()

print("\n[Legenda metriche titoli]")
print(" DY = Dividend Yield TTM")
print(" DivC5 = Crescita media annua dividendo (~5y)")
print(" CAGR5 = Crescita media annua prezzo (~5y)")
print(" Slope = Trend log-prezzo annualizzato (~10y)")
print(" R2 = Qualità del trend di lungo periodo")
print(" DD = Max drawdown storico")
print(" Vol = Volatilità annualizzata")
print(" Z = Z-score vs media a 200 gg")
print(" DD12 = Distanza dal valore massimo a 12 mesi")

# =============== STEP 2: STABLE DIVIDEND PAYERS ===========

def select_stable_dividends():
    rows = []
    for sym in sorted(set(STABLE_UNIVERSE)):
        s = download_price(sym, PERIOD_LONG)
        if s.empty:
            continue

        slope, r2, dd, vol, z, dd12, cagr5 = linear_and_entry_metrics(s)
        if np.isnan(slope) or np.isnan(r2):
            continue

        price = float(s.iloc[-1])
        dy, dcagr5, payout = get_dividend_stats(sym, price)

        # Filtri hard
        if math.isnan(dy) or dy < STABLE_MIN_DY or dy > STABLE_MAX_DY:
            continue
        if not np.isnan(payout) and payout > STABLE_MAX_PAYOUT:
            continue
        if not np.isnan(dd) and dd < STABLE_MAX_DD:
            continue
        if not np.isnan(vol) and vol > STABLE_MAX_VOL:
            continue
        if r2 < STABLE_MIN_R2 or slope < STABLE_MIN_SLOPE:
            continue
        if not np.isnan(dd12) and (dd12 < DD12_MIN or dd12 > DD12_MAX):
            continue

        rows.append([
            sym, price, dy, dcagr5, payout,
            slope, r2, dd, vol, z, dd12, cagr5
        ])

    if not rows:
        return pd.DataFrame(columns=[
            "Symbol","Price","DY","DivCAGR5","Payout",
            "Slope","R2","DD","Vol","Z","DD12","CAGR5","Score"
        ])

    df = pd.DataFrame(rows, columns=[
        "Symbol","Price","DY","DivCAGR5","Payout",
        "Slope","R2","DD","Vol","Z","DD12","CAGR5"
    ])

    df["R_DY"]     = rank01(df["DY"], asc=False)
    df["R_DivGR"]  = rank01(df["DivCAGR5"].clip(lower=0), asc=False)
    df["R_Stab"]   = 0.5*rank01(df["DD"], asc=True) + 0.5*rank01(df["Vol"], asc=True)
    df["R_Trend"]  = 0.6*rank01(df["Slope"], asc=False) + 0.4*rank01(df["R2"], asc=False)

    # Entry score
    z_abs = df["Z"].abs()
    z_base = rank01(z_abs, asc=True)
    z_bonus = (df["Z"] < 0).astype(float) * 0.3
    z_score = 0.7*z_base + 0.3*z_bonus
    dd12_score = rank01(df["DD12"], asc=False)
    df["R_Entry"] = 0.6*z_score + 0.4*dd12_score

    df["Score"] = (
        0.35*df["R_DY"] +
        0.20*df["R_DivGR"] +
        0.20*df["R_Stab"] +
        0.10*df["R_Trend"] +
        0.15*df["R_Entry"]
    )

    df = df.sort_values("Score", ascending=False).reset_index(drop=True)
    return df

stable_df = select_stable_dividends()

print("\n=== STABLE DIVIDEND PAYERS ===")
if stable_df.empty:
    print("Nessun titolo stabile trovato.")
else:
    top_stable = stable_df.head(TOP_WINNERS).copy()
    hon_stable = stable_df.iloc[TOP_WINNERS:TOP_WINNERS+HONORABLE_MENTIONS].copy()

    bw = sent["weights"]["STABLE_DIV"] * CAPITAL
    scores = top_stable["Score"].clip(lower=0)
    w = (scores / scores.sum()).values if scores.sum() > 0 else np.array([1/TOP_WINNERS]*TOP_WINNERS)

    top_stable["BucketWeight_%"] = (w * 100).round(2)
    top_stable["EUR"] = (w * bw).round(2)

    print("\nTop Stable Dividend Picks:")
    display(top_stable[[
        "Symbol","Price","BucketWeight_%","EUR",
        "Score","DY","DivCAGR5","Payout","CAGR5",
        "Slope","R2","DD","Vol","Z","DD12"
    ]])

    print("\nStable Dividend — Honorable Mentions:")
    display(hon_stable[[
        "Symbol","Price","Score","DY","DivCAGR5","CAGR5",
        "Slope","R2","DD","Vol","Z","DD12"
    ]])

    for sym in top_stable["Symbol"]:
        s = download_price(sym, PERIOD_LONG)
        if s.empty:
            continue
        plt.figure(figsize=(8,3))
        plt.style.use("dark_background")
        plt.plot(s.index, s.values, lw=2, color="#00c8ff")
        plt.title(f"{sym} — Stable Dividend (10y)", color="white")
        plt.grid(alpha=0.25)
        plt.xlabel("Date", color="gray")
        plt.ylabel("Price", color="gray")
        plt.tight_layout()
        plt.show()

# =============== STEP 3: HIGH GROWTH COMPOUNDERS =========

def select_growth_compounders():
    rows = []
    for sym in sorted(set(GROWTH_UNIVERSE)):
        s = download_price(sym, PERIOD_LONG)
        if s.empty:
            continue

        slope, r2, dd, vol, z, dd12, cagr5 = linear_and_entry_metrics(s)
        if np.isnan(slope) or np.isnan(r2) or np.isnan(cagr5):
            continue

        t = yf.Ticker(sym)
        info = t.info or {}
        roe  = safe(info.get("returnOnEquity", np.nan))
        opm  = safe(info.get("operatingMargins", np.nan))
        revg = safe(info.get("revenueGrowth", np.nan))
        earng= safe(info.get("earningsGrowth", np.nan))
        pe   = safe(info.get("trailingPE", np.nan))
        pb   = safe(info.get("priceToBook", np.nan))

        # Filtri crescita & qualità
        if cagr5 < GROWTH_MIN_CAGR5:
            continue
        if slope < GROWTH_MIN_SLOPE or r2 < GROWTH_MIN_R2:
            continue
        if not np.isnan(dd) and dd < GROWTH_MAX_DD:
            continue
        if not np.isnan(vol) and vol > GROWTH_MAX_VOL:
            continue
        if not np.isnan(roe) and roe < 0.10:
            continue
        if not np.isnan(opm) and opm < 0.10:
            continue
        if not np.isnan(dd12) and (dd12 < DD12_MIN or dd12 > DD12_MAX):
            continue

        price = float(s.iloc[-1])

        rows.append([
            sym, price, cagr5, slope, r2, dd, vol, z, dd12,
            roe, opm, revg, earng, pe, pb
        ])

    if not rows:
        return pd.DataFrame(columns=[
            "Symbol","Price","CAGR5","Slope","R2","DD","Vol",
            "Z","DD12","ROE","OPM","RevG","EarnG","PE","PB","Score"
        ])

    df = pd.DataFrame(rows, columns=[
        "Symbol","Price","CAGR5","Slope","R2","DD","Vol",
        "Z","DD12","ROE","OPM","RevG","EarnG","PE","PB"
    ])

    df["R_Growth"] = 0.6*rank01(df["CAGR5"], asc=False) + 0.4*rank01(df["Slope"], asc=False)
    df["R_Qual"]   = 0.5*rank01(df["ROE"], asc=False) + 0.5*rank01(df["OPM"], asc=False)
    df["R_Stab"]   = 0.5*rank01(df["DD"], asc=True) + 0.5*rank01(df["Vol"], asc=True)
    df["R_Val"]    = 0.7*rank01(df["PE"], asc=True) + 0.3*rank01(df["PB"], asc=True)

    z_abs = df["Z"].abs()
    z_base = rank01(z_abs, asc=True)
    z_bonus = (df["Z"] < 0).astype(float) * 0.3
    z_score = 0.7*z_base + 0.3*z_bonus
    dd12_score = rank01(df["DD12"], asc=False)
    df["R_Entry"] = 0.6*z_score + 0.4*dd12_score

    df["Score"] = (
        0.40*df["R_Growth"] +
        0.20*df["R_Qual"] +
        0.15*df["R_Stab"] +
        0.10*df["R_Val"] +
        0.15*df["R_Entry"]
    )

    df = df.sort_values("Score", ascending=False).reset_index(drop=True)
    return df

growth_df = select_growth_compounders()

print("\n=== HIGH GROWTH COMPOUNDERS ===")
if growth_df.empty:
    print("Nessun compounder growth trovato.")
else:
    top_growth = growth_df.head(TOP_WINNERS).copy()
    hon_growth = growth_df.iloc[TOP_WINNERS:TOP_WINNERS+HONORABLE_MENTIONS].copy()

    bw = sent["weights"]["GROWTH"] * CAPITAL
    scores = top_growth["Score"].clip(lower=0)
    w = (scores / scores.sum()).values if scores.sum() > 0 else np.array([1/TOP_WINNERS]*TOP_WINNERS)

    top_growth["BucketWeight_%"] = (w * 100).round(2)
    top_growth["EUR"] = (w * bw).round(2)

    print("\nTop High Growth Compounders:")
    display(top_growth[[
        "Symbol","Price","BucketWeight_%","EUR",
        "Score","CAGR5","Slope","R2","DD","Vol",
        "Z","DD12","ROE","OPM","RevG","EarnG","PE","PB"
    ]])

    print("\nHigh Growth — Honorable Mentions:")
    display(hon_growth[[
        "Symbol","Price","Score","CAGR5","Slope","R2","DD","Vol",
        "Z","DD12","ROE","OPM","RevG","EarnG","PE","PB"
    ]])

    for sym in top_growth["Symbol"]:
        s = download_price(sym, PERIOD_LONG)
        if s.empty:
            continue
        plt.figure(figsize=(8,3))
        plt.style.use("dark_background")
        plt.plot(s.index, s.values, lw=2, color="#8cff9b")
        plt.title(f"{sym} — High Growth Compounder (10y)", color="white")
        plt.grid(alpha=0.25)
        plt.xlabel("Date", color="gray")
        plt.ylabel("Price", color="gray")
        plt.tight_layout()
        plt.show()

# =============== STEP 4: ETF CORE / EXPOSURES (BTC & GOLD) =============

def select_etfs(sent_dict):
    """
    Seleziona ETF core + BTC-USD + GLD.
    Logica Buy&Hold-friendly:
      - ETF azionari globali restano il cuore.
      - BTC & Gold sono micro-tilt nel bucket ETF_CORE, SOLO sul nuovo capitale.
      - Caps dinamici guidati da VIX e z_spy:
          * VIX basso -> più spazio a BTC, meno a Gold.
          * VIX alto / z_spy negativo -> più spazio a Gold, meno a BTC.
    Nessuna vendita implicita: questo output dice solo dove mettere i prossimi soldi.
    """
    regime = sent_dict["regime"]
    met = sent_dict.get("metrics", {})
    vix = met.get("vix", 20.0)
    z_spy = met.get("z_spy", 0.0)

    rows = []
    for sym in sorted(set(ETF_UNIVERSE)):
        s = download_price(sym, "5y")
        if s.empty:
            continue

        slope, r2, dd, vol, z, dd12, cagr5 = linear_and_entry_metrics(s)
        if np.isnan(slope) or np.isnan(r2):
            continue

        is_btc = (sym == "BTC-USD")
        is_gold = (sym == "GLD")

        # ---- Filtri specifici BTC (growth volatile, ma solo serio trend di lungo periodo) ----
        if is_btc:
            # Considera BTC sempre come asset secolare, ma:
            # - richiedi forte track record; evita se collassato
            if math.isnan(cagr5) or cagr5 < 0.25:
                continue
            if not np.isnan(vol) and vol > 1.0:      # >100% annua: troppo estremo
                continue
            if not np.isnan(dd) and dd < -0.90:     # drawdown storico peggio di -90%: eccesso
                continue

        # ---- Filtri specifici Gold ----
        if is_gold:
            # Oro è difensivo: vogliamo che almeno tenga botta nel lungo termine
            if not np.isnan(vol) and vol > 0.40:
                continue
            if not np.isnan(dd) and dd < -0.45:
                continue
            if not np.isnan(cagr5) and cagr5 < -0.02:
                continue

        rows.append([sym, float(s.iloc[-1]), slope, r2, dd, vol, z, dd12, cagr5])

    if not rows:
        return pd.DataFrame(columns=["Symbol","Price","Score"])

    df = pd.DataFrame(rows, columns=[
        "Symbol","Price","Slope","R2","DD","Vol","Z","DD12","CAGR5"
    ])

    # Score generale (stabilità + rendimento)
    df["R_Stab"] = 0.5*rank01(df["DD"], asc=True) + 0.5*rank01(df["Vol"], asc=True)
    df["Score"] = (
        0.4*rank01(df["CAGR5"], asc=False) +
        0.2*rank01(df["Slope"], asc=False) +
        0.2*rank01(df["R2"], asc=False) +
        0.2*df["R_Stab"]
    )

    df = df.sort_values("Score", ascending=False).reset_index(drop=True)

    # ---------- Caps dinamici BTC / GOLD in funzione di VIX & z_spy ----------

    # BTC: più spazio con volatilità moderata e mercato non in bolla né in panico.
    if vix < 15 and abs(z_spy) < 1.0:
        max_btc = 0.12  # fino al 12% del bucket ETF_CORE
    elif 15 <= vix <= 25:
        max_btc = 0.08
    elif 25 < vix <= 35:
        max_btc = 0.05
    else:
        max_btc = 0.03

    # Gold: più spazio con VIX alto o z_spy negativo.
    if vix > 35 or z_spy < -0.5:
        max_gld = 0.35
    elif 25 < vix <= 35 or z_spy < 0:
        max_gld = 0.25
    elif 18 < vix <= 25:
        max_gld = 0.15
    else:
        max_gld = 0.10

    return df, max_btc, max_gld

etf_df, MAX_BTC, MAX_GLD = select_etfs(sent)

print("\n=== ETF CORE / EXPOSURES (incl. BTC & Gold, dinamici su VIX/Z) ===")
if etf_df.empty:
    print("Nessun ETF/exposure idoneo trovato.")
else:
    top_etf = etf_df.head(ETF_TOP).copy()
    bw = sent["weights"]["ETF_CORE"] * CAPITAL

    # Pesi iniziali proporzionali allo Score
    scores = top_etf["Score"].clip(lower=0)
    if scores.sum() > 0:
        w = scores / scores.sum()
    else:
        w = pd.Series([1/len(top_etf)]*len(top_etf), index=top_etf.index)

    w = pd.Series(w.values, index=top_etf["Symbol"])

    # Applica caps dinamici su BTC e GLD SOLO sul nuovo capitale
    if "BTC-USD" in w.index:
        w["BTC-USD"] = min(w["BTC-USD"], MAX_BTC)
    if "GLD" in w.index:
        w["GLD"] = min(w["GLD"], MAX_GLD)

    # Rinormalizza dopo i cap
    w = w / w.sum()

    top_etf["BucketWeight_%"] = (w.values * 100).round(2)
    top_etf["EUR"] = (w.values * bw).round(2)

    print(f"\nPeso massimo BTC nel bucket ETF_CORE: {MAX_BTC*100:.1f}%")
    print(f"Peso massimo GOLD nel bucket ETF_CORE: {MAX_GLD*100:.1f}%")

    print("\nTop ETF / Exposures per il bucket ETF_CORE:")
    display(top_etf[[
        "Symbol","Price","BucketWeight_%","EUR",
        "Score","CAGR5","Slope","R2","DD","Vol","Z","DD12"
    ]])

    for sym in top_etf["Symbol"]:
        s = download_price(sym, "5y")
        if s.empty:
            continue
        plt.figure(figsize=(8,3))
        plt.style.use("dark_background")
        plt.plot(s.index, s.values, lw=2, color="orange")
        plt.title(f"{sym} — Core Exposure (5y)", color="white")
        plt.grid(alpha=0.25)
        plt.xlabel("Date", color="gray")
        plt.ylabel("Price", color="gray")
        plt.tight_layout()
        plt.show()
